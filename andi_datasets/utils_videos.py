# AUTOGENERATED! DO NOT EDIT! File to edit: source_nbs/utils_videos.ipynb (unless otherwise specified).

__all__ = ['get_video_andi']

# Cell
import numpy as np
import matplotlib.pyplot as plt

import deeptrack as dt

# Cell
def get_video_andi(
    trajectory_data, scatter_kwargs={}, optics_kwargs={}, noise_kwargs={}
):
    """
    Generates a video from the trajectories generated by create_dataset(). Uses process_data_from_andi() to adjust the initial positions of the trajectories.
    Arguments:
        trajectory_data: AnDi dataset generated from create_dataset()
        scatter_kwargs (dict): Can be used to change the particle properties (intensity, z, position)
        optics_kwargs (dict): Can be used to change the optics properties (NA, wavelength, resolution, magnification, output_region)
        noise_kwargs (dict): Can be used to modify the snr of the video

    Users need to do get_video_andi(trajectory_data).update().resolve() to generate the video, and get_video_andi(trajectory_data).update().plot() to visualize the video

    """

    _particle_dict = {
        "intensity": lambda: 1
        + np.random.rand() * 9,  # particle intensities can be modified
        "z": lambda: np.random.rand() * 5,
        "refractive_index": lambda: 1.4 + np.random.rand() * 0.2,
        "position_unit": "pixel",
    }

    _optics_dict = {
        "NA": lambda: 0.6 + np.random.rand() * 0.2,  # 1,
        "wavelength": 500e-9,
        "resolution": 1e-6,  # 5e-6
        "magnification": 10,  # effective pixel size is 100 nm # magnifiction changed to 10
        "upscale": 4,
        "refractive_index_medium": 1.33,
        "output_region": [0, 0, 128, 128],
    }

    _noise_dict = {
        "snr": lambda: 4 + np.random.rand() * 3,
    }

    # Update the dictionaries with the user-defined values
    _particle_dict.update(scatter_kwargs)
    _optics_dict.update(optics_kwargs)
    _noise_dict.update(noise_kwargs)

    # Reshapa the trajectory
    trajectory_data = np.moveaxis(trajectory_data, 0, 1)

    # Generate point particles
    particle = dt.PointParticle(
        trajectories=trajectory_data,
        replicate_index=lambda _ID: _ID,
        trajectory=lambda replicate_index, trajectories: dt.units.pixel
        * trajectories[replicate_index[-1]],
        traj_pointer=lambda replicate_index: replicate_index[-1],
        number_of_particles=trajectory_data.shape[0],
        traj_length=trajectory_data.shape[1],
        position=lambda trajectory: trajectory[0],
        **_particle_dict,
    )

    # Make it sequential
    sequential_particle = dt.Sequential(
        particle,
        position=lambda trajectory, sequence_step: trajectory[sequence_step],
    )

    # Define optical setup
    optics = dt.Fluorescence(**_optics_dict)

    # Normalise the intensity
    normalization = dt.NormalizeMinMax(
        min=lambda: np.random.rand() * 0.4,
        max=lambda min: min + 0.1 + np.random.rand() * 0.5,
    )

    # Add shot noise
    noise = dt.Poisson(
        **_noise_dict,
        background=normalization.min,
    )

    # sample
    sample = optics(particle ^ particle.number_of_particles) >> normalization >> noise

    # Sequential sample
    sequential_sample = dt.Sequence(
        sample,
        trajectory=particle.trajectories,
        sequence_length=particle.traj_length,
    )

    return sequential_sample